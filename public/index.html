<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Hello Virgil</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/antd/3.0.0/antd.min.css">
	<link rel="stylesheet" href="/styles.css">

	<script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
	<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
	<script crossorigin src="https://unpkg.com/react-router-dom/umd/react-router-dom.min.js"></script>
	<script crossorigin src="https://unpkg.com/prop-types/prop-types.js"></script>
	<script crossorigin src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
	<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.19.3/moment.min.js"></script>
	<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/antd/3.0.0/antd.min.js"></script>
	<script crossorigin src="https://cdn.virgilsecurity.com/packages/javascript/sdk/4.5.1/virgil-sdk.min.js"></script>
</head>
<body>
<div id="root"></div>

<script>
	var VIRGIL_APP_ACCESS_TOKEN = '{{VIRGIL_APP_ACCESS_TOKEN}}';
</script>
<script>
	/*
	* memoize.js
	* by @philogb and @addyosmani
	* with further optimizations by @mathias
	* and @DmitryBaranovsk
	* perf tests: http://bit.ly/q3zpG3
	* Released under an MIT license.
	*/
	function memoize( fn ) {
		return function () {
			var args = Array.prototype.slice.call(arguments),
				hash = "",
				i = args.length;
			var currentArg = null;
			while (i--) {
				currentArg = args[i];
				hash += (currentArg === Object(currentArg)) ?
					JSON.stringify(currentArg) : currentArg;
				fn.memoize || (fn.memoize = {});
			}
			return (hash in fn.memoize) ? fn.memoize[hash] :
				fn.memoize[hash] = fn.apply(this, args);
		};
	}
</script>
<script type="text/babel">
	const { Form, Icon, Input, Button, Select, Avatar, Layout, Menu } = window.antd;
	const { Item: FormItem } = Form;
	const { TextArea } = Input;
	const { Option } = Select;
	const { Header, Content, Footer, Sider } = Layout;

	const { BrowserRouter, Link, Switch, Route, Redirect } = window.ReactRouterDOM;

	class StoreProvider extends React.Component {
		static contextName = '__app_state__';

		static Renderer = class extends React.Component {
			static childContextTypes = {
				[StoreProvider.contextName]: PropTypes.object.isRequired
			};

			getChildContext() {
				return {
					[StoreProvider.contextName]: this.props.store
				};
			}

			render() {
				return this.props.children;
			}
		};

		render() {
			const { children, ...props } = this.props;
			return (
				<Store {...props} render={store => (
					<StoreProvider.Renderer store={store} children={children} />
				)}/>
			);
		}
	}

	function ConnectedStore(props, context) {
		return props.render(context[StoreProvider.contextName]);
	}

	ConnectedStore.contextTypes = {
		[StoreProvider.contextName]: PropTypes.object.isRequired
	};

	const http = (function () {
		function handleResponse(res) {
			if (res.ok) {
				return res.json();
			}

			if (res.status === 400) {
				return res.json()
					.then(data => {
						const error = new Error(data.message);
						error.statusCode = data.statusCode;
						error.name = data.error;

						return Promise.reject(error);
					})
			}

			return Promise.reject(new Error('Unexpected server error'));
		}

		return {
			get(url) {
				return fetch(url)
					.then(handleResponse);
			},

			post(url, data) {
				return fetch(url, {
					method: 'POST',
					body: JSON.stringify(data),
					headers: new Headers({ 'Content-Type': 'application/json' })
				}).then(handleResponse)
			}
		};
	})();

	const virgilHelper = (function () {
		const virgilApi = window.virgil.API({
			accessToken: VIRGIL_APP_ACCESS_TOKEN
		});

		return {
			createKey() {
				return virgilApi.keys.generate();
			},

			loadKey(username, password) {
				return virgilApi.keys.exists(username)
					.then(exists => {
						if (!exists) {
							return Promise.reject(new Error(`A private key for user ${username} does not exist.`));
						}

						return virgilApi.keys.load(username, password)
							.catch(e => {
								if (e.code === '90010') {
									return Promise.reject(
										new Error(
											'Unable to decrypt the private key with the given password. ' +
											'Password is invalid for the given username.'
										)
									);
								}
							});
					});
			},

			createCardRequest(username, virgilKey) {
				return virgilApi.cards.create(username, virgilKey);
			},

			getCard: memoize(cardId => virgilApi.cards.get(cardId)),

			encryptForMultiple(data, recipients) {
				return virgilApi.encryptFor(data, recipients);
			}
		}
	})();

	class Store extends React.Component {
		initialState = { users: [], currentUser: null };
		state = this.initialState;

		render() {
			const handleError = (e) => {
				console.error(e);
				window.antd.message.error(e.message);
			};

			return this.props.render({
				currentUser: this.state.currentUser,
				users: this.state.users,
				fetchUsers: () => {
					http.get('/users')
						.then(users => {
							this.setState({ users: users });
						})
						.catch(handleError);
				},
				registerUser: ({ username, password }) => {
					const key = virgilHelper.createKey();
					const card = virgilHelper.createCardRequest(username, key);

					http.post('/users/', { username, csr: card.export() })
						.then(() => key.save(username, password))
						.then(key => this.setState({ currentUser: { username, key } }))
						.catch(handleError);
				},
				signIn: ({ username, password }) => {
					return virgilHelper.loadKey(username, password)
						.then(key => this.setState({ currentUser: { username, key } }))
						.catch(handleError);
				},
				encrypt: ({ recipients, message }) => {
					const virgilCardsPromise = Promise.all(
						recipients.map(recipient => virgilHelper.getCard(recipient))
					);

					return virgilCardsPromise.then(virgilCards => {
						return virgilHelper.encryptForMultiple(message, virgilCards);
					}).catch(handleError);
				},
				decrypt: ({ ciphertext }) => {
					return Promise.resolve()
						.then(() => {
							return this.state.currentUser.key.decrypt(ciphertext).toString('utf8');
						})
						.catch(e => {
							if (e.code === '90002') {
								return Promise.reject(
									new Error(
										'Unable to decrypt the given data. ' +
										'It hasn\'t been encrypted with your public key.'
									)
								);
							}

							return Promise.reject(e);
						})
						.catch(handleError);

				}
			});
		}
	}

	const AuthForm = window.antd.Form.create()(class extends React.Component {
		render() {
			const { getFieldDecorator } = this.props.form;
			return (
				<Form onSubmit={this.handleSubmit} className="demo-form">
					<FormItem>
						{getFieldDecorator('username', {
							rules: [{ required: true, message: 'Please enter your username!' }],
						})(
							<Input
								prefix={<Icon type="user" style={{ color: 'rgba(0,0,0,.25)' }} />}
								placeholder="Username"
							/>
						)}
					</FormItem>
					<FormItem>
						{getFieldDecorator('password', {
							rules: [{ required: true, message: 'Please enter your password!' }],
						})(
							<Input
								prefix={<Icon type="lock" style={{ color: 'rgba(0,0,0,.25)' }} />}
								type="password"
								placeholder="Private Key Password"
							/>
						)}
					</FormItem>
					<FormItem>
						<Button type="primary" htmlType="submit" className="demo-form-button">
							Sign Up
						</Button>
					</FormItem>
				</Form>
			);
		}

		handleSubmit = (e) => {
			e.preventDefault();
			this.props.form.validateFields((err, values) => {
				if (!err) {
					this.props.onSubmit && this.props.onSubmit(values);
				}
			});
		}
	});

	function RegisterForm(props) {
		return (
			<div>
				<h2 className="auth-title">Sign up to start encrypting and decrypting messages</h2>
				<AuthForm onSubmit={props.store.registerUser}/>
				<div className="auth-form-footer">
					<span>Have a key? </span>
					<Link to="/auth/signin">Sign In</Link>
				</div>
			</div>
		);
	}

	function LoginForm(props) {
		return (
			<div>
				<h2 className="auth-title">Sign in to continue encrypting and decrypting messages</h2>
				<AuthForm onSubmit={props.store.signIn}/>
				<div className="auth-form-footer">
					<span>Don't have a key? </span>
					<Link to="/auth/signup">Sign Up</Link>
				</div>
			</div>
		);
	}

	const EncryptForm = window.antd.Form.create()(class extends React.Component {
		state = {
			ciphertext: ''
		};

		render() {
			const { getFieldDecorator } = this.props.form;
			const { users } = this.props.store;
			return (
				<div>
					<Form onSubmit={this.handleSubmit} className="demo-form">
						<FormItem label="Recipients">
							{getFieldDecorator('recipients', {
								rules: [{ required: true, message: 'Please select recipient(s)', type: 'array' }]
							})(
								<Select placeholder="Whom to encrypt the message for" mode="multiple">
									{
										users.map(user => (
											<Option key={user.id} value={user.virgilCardId}>{user.username}</Option>
										))
									}
								</Select>
							)}
						</FormItem>
						<FormItem label="Message">
							{getFieldDecorator('message', {
								rules: [{ required: true, message: 'Please enter the message!' }],
							})(
								<TextArea placeholder="Secret message" autosize={{ minRows: 2, maxRows: 12 }} />
							)}
						</FormItem>
						<FormItem>
							<Button type="primary" htmlType="submit" className="demo-form-button">
								Encrypt
							</Button>
						</FormItem>
						{ this.state.ciphertext &&
							<TextArea
								value={this.state.ciphertext}
								autosize={{ minRows: 6, maxRows: 12 }}
								readonly
							/>
						}
					</Form>
				</div>
			);
		}

		handleSubmit = (e) => {
			e.preventDefault();
			this.props.form.validateFields((err, values) => {
				if (!err) {
					this.props.store.encrypt(values)
						.then(ciphertext => {
							this.setState({ ciphertext: ciphertext.toString('base64') });
						});
				}
			});
		}
	});

	const DecryptForm = window.antd.Form.create()(class extends React.Component {
		state = {
			plaintext: ''
		};

		render() {
			const { getFieldDecorator } = this.props.form;
			return (
				<div>
					<Form onSubmit={this.handleSubmit} className="demo-form">
						<FormItem label="Ciphertext">
							{getFieldDecorator('ciphertext', {
								rules: [{ required: true, message: 'Please enter the ciphertext!' }],
							})(
								<TextArea
									placeholder="That long base64-encoded string you've got from Encrypt form"
									autosize={{ minRows: 6, maxRows: 12 }}
								/>
							)}
						</FormItem>
						<FormItem>
							<Button type="primary" htmlType="submit" className="demo-form-button">
								Decrypt
							</Button>
						</FormItem>
						{ this.state.plaintext &&
							<TextArea
								value={this.state.plaintext}
								autosize={{ minRows: 6, maxRows: 12 }}
								readonly
							/>
						}
					</Form>
				</div>
			);
		}

		handleSubmit = (e) => {
			e.preventDefault();
			this.props.form.validateFields((err, values) => {
				if (!err) {
					this.props.store.decrypt(values)
						.then(plaintext => {
							this.setState({ plaintext });
						});
				}
			});
		}
	});

	function UserProfile() {
		return (
			<ConnectedStore render={store =>
				store.currentUser && (
					<div className="profile">
						<Avatar icon="user" size="small" />
						<span className="username">{store.currentUser.username}</span>
					</div>
				)
			} />
		);
	}

	function Logo() {
		return (
			<div className="logo">
				<h1>Virgil Hello World</h1>
			</div>
		);
	}

	function AppFooter() {
		return (
			<Footer style={{ textAlign: 'center' }}>
				2017 Virgil Security, Inc.
			</Footer>
		);
	}

	class Home extends React.Component {
		componentDidMount() {
			this.props.store.fetchUsers();
		}

		render() {
			return (
				<Layout className="layout">
					<Sider className="sidebar">
						<Logo />
						<Menu
							theme="dark"
							mode="inline"
							style={{ lineHeight: '64px' }}
							defaultSelectedKeys={[ this.props.location.pathname ]}
						>
							<Menu.Item key="/encrypt">
								<Link to="/encrypt">Encrypt</Link>
							</Menu.Item>
							<Menu.Item key="/decrypt">
								<Link to="/decrypt">Decrypt</Link>
							</Menu.Item>
						</Menu>
						<div className="sidebar-footer">
							<UserProfile />
						</div>
					</Sider>
					<Layout>
						<Content style={{ padding: '0 50px'}}>
							<ConnectedStore render={store => this.renderContent(store)}/>
						</Content>
						<AppFooter />
					</Layout>
				</Layout>
			);
		}

		renderContent = (store) => {
			return (
				<Switch>
					<Route path="/encrypt" render={() => this.renderEncrypt(store)}/>
					<Route path="/decrypt" render={() => this.renderDecrypt(store)}/>
				</Switch>
			);
		}

		renderEncrypt(store) {
			return <EncryptForm store={store} />;
		}

		renderDecrypt(store) {
			return <DecryptForm store={store} />;
		}
	}

	class Auth extends React.Component {
		render() {
			return (
				<ConnectedStore render={store =>
					store.currentUser
					? <Redirect to='/encrypt' />
					: (
						<Layout className="layout">
							<Header className="auth-header">
								<Logo />
							</Header>
							<Content>
								<Switch>
									<Route path="/auth/signup" render={() => RegisterForm({store}) } />
									<Route path="/auth/signin" render={() => LoginForm({store}) } />
								</Switch>
							</Content>
							<AppFooter />
						</Layout>
					)
				}/>
			);
		}
	}

	class PrivateRoute extends React.Component {
		render() {
			const { component: Component, render, store, redirectTo, ...rest } = this.props;
			const isAuthenticated = Boolean(store.currentUser);
			if (isAuthenticated) {
				return Component ? <Component store={store} {...rest} /> : render({...rest, store});
			} else {
				return <Redirect to={redirectTo} />;
			}
		}
	}

	class App extends React.Component {
		render() {
			return (
				<BrowserRouter>
					<StoreProvider>
						<ConnectedStore render={store => (
							<Switch>
								<Route path="/auth" component={Auth} />
								<PrivateRoute
									path="/"
									render={(props) => this.renderHome(props, store)}
									redirectTo="/auth/signin"
									store={store}
								/>
							</Switch>
						)}/>
					</StoreProvider>
				</BrowserRouter>
			);
		}

		renderHome = (props, store) => {
			return <Home store={store} {...props} />
		}
	}

	ReactDOM.render(
		<App />,
		document.getElementById('root')
	);
</script>
</body>
</html>